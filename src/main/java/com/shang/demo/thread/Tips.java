package com.shang.demo.thread;

/**
 * 多线程相关知识点
 */
public class Tips {


    /*线程方法: wait notify notifyAll sleep join yield interrupt
     1 wait() : 线程进入WAITING 状态,会释放对象的锁
     2 sleep() : 不会释放当前对象的锁,进入TIME-WAITING 状态
     3 yield() : 线程让步,当前现场让出CPU的执行时间片,与其他线程一起重新竞争CPU.
     4 interrupt() : 给线程一个信号,会影响这个线程内部的一个中断标识位,而找个线程本身不会立即阻塞或者终止.
     5 join() : 当前线程阻塞,过渡到其他的线程,等待其他线程的终止,然后变为就绪状态
     6 notify() : 唤醒在此对象监视器上等待的随机一个线程
     7 notifyAll(): 唤醒在此对象监视器上等待的所有的线程
     8 enumerate() : 枚举程序中的线程
       isDaemon(): 判断一个线程是否为守护线程
     9 setDaemon() : 设置一个线程为守护线程.(用户线程和守护线程的区别就是,是否依赖与主线程的结束而结束)
     10 setName() : 为线程设置一个名称
     11 activeCount(): 程序中活跃的线程数目
     12 currentThread(): 得到当前线程
     13 setPriority() : 设置一个线程的优先级

     进程: 有时候也叫任务,是指一个程序运行的实例,
     线程: linux中线程就是能并行运行,且与他们的父类进程共享同一地址空间和其他资源的轻量级进程
     上下文: CPU寄存器和程序计数器的内容
     寄存器: 是CPU内部数量较少,但是速度很快的内存,与之对应的是RAM主内存.通常对运算中间值的快速访问,来提高计算机的运行速度.
     程序计数器: 是一个专用的寄存器,存的是正在执行的指令的位置或者下一个将要被执行的指令的位置.
     PCB(进程控制块)--"切换帧": 上下文切换的过程中信息保存在PCB中,

    上下文切换的活动:
     1,挂起一个进程，将这个进程在 CPU 中的状态(上下文)存储于内存中的某处。
     2,在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。
     3,跳转到程序计数器所指向的位置(即跳转到进程被中断时的代码行)，以恢复该进程在程序中

     同步锁: JAVA中使用synchronized 关键字来取得一个对象的同步锁
     死锁: 多个线程同时被阻塞


     线程复用: 每一个Thread 类都有一个start方法,当调用start 启动线程时,JAVA虚拟机会调用该类的run方法,
     实际上是调用了Runnable 对象的run()方法,
     我们可以在Start() 方法中添加不断循环调用传递来的Runnable对象, 这就是线程池的实现原理.
     线程池的主要工作就是控制运行的线程的数量,处理过程中将任务放入队列.

     线程组成部分:
       1,线程池管理器: 用于创建并管理线程池
       2,工作线程: 线程池中的线程
       3,任务接口: 每个任务必须实现的接口,用于工作线程的调度运行
       4,任务队列: 用于存放待处理的任务,提供一种缓冲机制

     JAVA的线程池是通过Executor 框架实现的

     JAVA的阻塞队列:
        ArrayBlockingQueue :由数组结构组成的有界阻塞队列。
        LinkedBlockingQueue :由链表结构组成的有界阻塞队列。
        PriorityBlockingQueue :支持优先级排序的无界阻塞队列。
        DelayQueue:使用优先级队列实现的无界阻塞队列。
        SynchronousQueue:不存储元素的阻塞队列。
        LinkedTransferQueue:由链表结构组成的无界阻塞队列。
        LinkedBlockingDeque:由链表结构组成的双向阻塞队列
     */


}
