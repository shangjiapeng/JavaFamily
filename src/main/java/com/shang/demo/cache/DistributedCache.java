package com.shang.demo.cache;

/**
 * 分布式缓存
 */
public class DistributedCache {

    /**
     * 缓存雪崩:
     * 由于原缓存失效,而心缓存还没有生成期间,所有原本访问缓存的请求都去查询数据库了,
     * 而对CPU和内存造成巨大的压力,严重的会导致数据库宕机,从而形成一系列连锁反应,造成整个系统崩溃
     * 解决方法:
     * 1 一般并发量不是特别多的时候,使用加锁排队
     * 2 给每一个缓存数据增加相应的缓存标记,记录缓存是否失效,如果缓存失效,则更新数据缓存
     * 3 为key设置不同的缓存失效时间
     */


    /**
     * 缓存穿透:
     * 用于查询数据,在数据库没有,自然缓存中也不会有,这样就导致用户查询的时候,
     * 在缓存中找不到,每次都要去数据库再查询一遍,然后返回空值,
     * 这样就相当于进行了两次无用的查询,这样请求就绕过缓存直接查询数据库,影响缓存命中率
     * 解决方法:
     * 1 布隆过滤器(最常见):
     * 将所有可能存在的数据的哈希存到一个足够大的bitmap中去,不存在的数据会被bitmap拦截掉
     * 2 空值缓存(简单粗暴):
     * 如果一个查询返回的数据为空(不管是数据不存在还是系统故障)我们仍将这个空结果进行缓存,
     * 但是过期时间很短(不超过5分钟)这样第二次到缓存中获取就有一个默认的空值,而不会继续访问数据库
     */

    /**
     * 缓存预热:
     * 在系统上线之后,将相关的缓存数据直接加载到缓存系统,
     * 这样就可以避免在用户请求时候,先查询数据库,然后再讲数据缓存的问题
     */

    /**
     * 缓存更新
     * 缓存更新除了缓存服务器自带的缓存失效策略之外(Redis 中默认有6种策略可供选择)
     * 我们还可以根据具体的业务需求进行自定义的缓存淘汰机制
     * 1 定期去清理过期的缓存
     * 2 当有用于请求过来时,再判断这个请求所用到的缓存是否过期,如果过期就更新数据
     */

    /**
     * 缓存降级
     * 当访问量剧增,服务出现问题(如响应时间慢或者不响应)或者非核心服务影响到核心流程时,仍然要保证服务还是可用的
     * 即使时有损服务,系统可以根据一些关键数据进行自动降级,也可以配置开关试用人工降级,
     * 降级的最终目的时保证核心服务的可用
     *
     */




}
